<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Single Transferable Vote Counter</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #0c0f1a; color: #e2e8f0; font-family: 'Segoe UI', 'Helvetica Neue', sans-serif; }
    #root { min-height: 100vh; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
  <script type="text/babel">
    const { useState, useCallback } = React;

    // ── STV Algorithm (Weighted Inclusive Gregory Method) ──────────────────

    function roundDisplay(val) {
      return parseFloat(val.toFixed(5)).toString();
    }

    function computeQuota(totalVotes, seats) {
      const raw = totalVotes / (seats + 1);
      return Math.ceil(raw * 100) / 100;
    }

    function runSTV(ballots, numSeats, numCandidates) {
      const candidateNames = Array.from({ length: numCandidates }, (_, i) => `Candidate ${i + 1}`);
      const totalVotes = ballots.length;
      const quota = computeQuota(totalVotes, numSeats);

      let papers = ballots.map((prefs) => ({
        prefs: prefs.filter((p) => p !== null && p !== undefined),
        weight: 1,
      }));

      const elected = new Set();
      const eliminated = new Set();
      const rounds = [];
      let seatsRemaining = numSeats;

      const getActivePref = (paper) => {
        for (const c of paper.prefs) {
          if (!elected.has(c) && !eliminated.has(c)) return c;
        }
        return null;
      };

      const tallyVotes = () => {
        const tally = {};
        for (let c = 0; c < numCandidates; c++) {
          if (!elected.has(c) && !eliminated.has(c)) tally[c] = 0;
        }
        for (const paper of papers) {
          const pref = getActivePref(paper);
          if (pref !== null && tally[pref] !== undefined) {
            tally[pref] += paper.weight;
          }
        }
        return tally;
      };

      let maxRounds = numCandidates * 2 + 10;
      while (seatsRemaining > 0 && maxRounds-- > 0) {
        const tally = tallyVotes();
        const activeCandidates = Object.keys(tally).map(Number);

        if (activeCandidates.length === 0) break;

        if (activeCandidates.length <= seatsRemaining) {
          const roundInfo = {
            type: "elect_remaining",
            tally: { ...tally },
            elected: [...activeCandidates],
            quota,
            description: `Remaining candidates (${activeCandidates.map((c) => candidateNames[c]).join(", ")}) elected to fill ${seatsRemaining} seat(s).`,
          };
          activeCandidates.forEach((c) => elected.add(c));
          seatsRemaining -= activeCandidates.length;
          rounds.push(roundInfo);
          break;
        }

        const overQuota = activeCandidates
          .filter((c) => tally[c] >= quota)
          .sort((a, b) => tally[b] - tally[a]);

        if (overQuota.length > 0) {
          const winner = overQuota[0];
          const surplus = tally[winner] - quota;
          const winnerPapers = papers.filter((p) => getActivePref(p) === winner);
          const totalWeight = winnerPapers.reduce((s, p) => s + p.weight, 0);

          elected.add(winner);
          seatsRemaining--;

          const roundInfo = {
            type: "elected",
            tally: { ...tally },
            candidate: winner,
            surplus,
            quota,
            description: `${candidateNames[winner]} elected with ${roundDisplay(tally[winner])} votes (quota: ${quota}). Surplus: ${roundDisplay(surplus)}.`,
          };

          if (surplus > 0 && seatsRemaining > 0) {
            const transferValue = totalWeight > 0 ? surplus / totalWeight : 0;
            for (const paper of winnerPapers) {
              paper.weight = paper.weight * transferValue;
            }
            roundInfo.description += ` Surplus transferred (transfer value: ${roundDisplay(transferValue)}).`;
          }

          rounds.push(roundInfo);
        } else {
          const minVotes = Math.min(...activeCandidates.map((c) => tally[c]));
          const weakest = activeCandidates.filter((c) => tally[c] === minVotes);
          const toEliminate = weakest[Math.floor(Math.random() * weakest.length)];
          eliminated.add(toEliminate);

          const wasTiebreak = weakest.length > 1;
          const roundInfo = {
            type: "eliminated",
            tally: { ...tally },
            candidate: toEliminate,
            quota,
            tiebreak: wasTiebreak,
            description: `${candidateNames[toEliminate]} eliminated with ${roundDisplay(tally[toEliminate])} votes (lowest).${wasTiebreak ? ` Tied with ${weakest.filter(c => c !== toEliminate).map(c => candidateNames[c]).join(", ")} \u2014 resolved by random tiebreaker.` : ""} Votes redistributed.`,
          };

          rounds.push(roundInfo);
        }
      }

      return { rounds, elected: [...elected], eliminated: [...eliminated], quota, candidateNames, totalVotes };
    }

    // ── Theme ─────────────────────────────────────────────────────────────

    const B = {
      bg: "#0c0f1a", card: "#151929", cardAlt: "#1a2035", border: "#2a3050",
      accent: "#4f8cff", accentSoft: "#4f8cff22",
      green: "#34d399", greenSoft: "#34d39922",
      red: "#f87171", redSoft: "#f8717122",
      orange: "#fbbf24", orangeSoft: "#fbbf2422",
      text: "#e2e8f0", textMuted: "#94a3b8", textDim: "#64748b",
    };

    const thStyle = {
      padding: "10px 8px", textAlign: "left", borderBottom: `2px solid ${B.border}`,
      color: B.textMuted, fontWeight: 600, fontSize: 12, whiteSpace: "nowrap",
    };
    const tdStyle = { padding: "6px 8px", borderBottom: `1px solid ${B.border}22` };
    const thSmall = {
      padding: "6px 8px", borderBottom: `1px solid ${B.border}44`, color: B.textDim,
      fontWeight: 600, fontSize: 11, textTransform: "uppercase", letterSpacing: "0.04em",
    };

    function ordinal(n) {
      const s = ["th", "st", "nd", "rd"];
      const v = n % 100;
      return n + (s[(v - 20) % 10] || s[v] || s[0]);
    }

    // ── Components ────────────────────────────────────────────────────────

    function Stat({ label, value }) {
      return (
        <div style={{ background: B.bg, borderRadius: 10, padding: "12px 20px", border: `1px solid ${B.border}` }}>
          <div style={{ fontSize: 11, color: B.textDim, fontWeight: 600, textTransform: "uppercase", letterSpacing: "0.04em" }}>{label}</div>
          <div style={{ fontSize: 22, fontWeight: 800, color: B.accent, marginTop: 2 }}>{value}</div>
        </div>
      );
    }

    function SetupPanel({ numSeats, setNumSeats, numCandidates, setNumCandidates, numVotes, setNumVotes, onNext }) {
      const [raw, setRaw] = useState({ seats: String(numSeats), candidates: String(numCandidates), votes: String(numVotes) });

      const fields = [
        { key: "seats", label: "Number of Seats", setter: setNumSeats, min: 1, max: 20, desc: "How many winners to elect" },
        { key: "candidates", label: "Number of Candidates", setter: setNumCandidates, min: 2, max: 26, desc: "Standing for election" },
        { key: "votes", label: "Number of Votes", setter: setNumVotes, min: 1, max: 500, desc: "Total ballot papers cast" },
      ];

      const handleChange = (key, value) => {
        setRaw((prev) => ({ ...prev, [key]: value }));
        const parsed = parseInt(value, 10);
        if (!isNaN(parsed)) fields.find((f) => f.key === key).setter(parsed);
      };

      const handleBlur = (key) => {
        const f = fields.find((f) => f.key === key);
        const parsed = parseInt(raw[key], 10);
        const clamped = isNaN(parsed) ? f.min : Math.max(f.min, Math.min(f.max, parsed));
        f.setter(clamped);
        setRaw((prev) => ({ ...prev, [key]: String(clamped) }));
      };

      const valid = numSeats >= 1 && numCandidates >= 2 && numVotes >= 1 && numSeats < numCandidates;

      return (
        <div style={{ background: B.card, borderRadius: 16, border: `1px solid ${B.border}`, padding: 40, maxWidth: 520, margin: "0 auto" }}>
          <h2 style={{ margin: "0 0 8px", fontSize: 22, fontWeight: 700 }}>Election Setup</h2>
          <p style={{ margin: "0 0 32px", color: B.textMuted, fontSize: 14 }}>Configure the election parameters, then enter ballots.</p>
          {fields.map((f) => (
            <div key={f.key} style={{ marginBottom: 24 }}>
              <label style={{ display: "block", fontSize: 13, fontWeight: 600, marginBottom: 6, color: B.text }}>{f.label}</label>
              <input type="number" min={f.min} max={f.max} value={raw[f.key]}
                onChange={(e) => handleChange(f.key, e.target.value)}
                onBlur={() => handleBlur(f.key)}
                style={{ width: "100%", padding: "12px 16px", borderRadius: 10, border: `1px solid ${B.border}`, background: B.bg, color: B.text, fontSize: 16, fontWeight: 600, boxSizing: "border-box", outline: "none" }}
              />
              <span style={{ fontSize: 12, color: B.textDim, marginTop: 4, display: "block" }}>{f.desc}</span>
            </div>
          ))}
          {numSeats >= numCandidates && <p style={{ color: B.red, fontSize: 13, margin: "0 0 16px" }}>Seats must be fewer than candidates.</p>}
          <button onClick={onNext} disabled={!valid} style={{
            width: "100%", padding: "14px", borderRadius: 10, border: "none",
            background: valid ? `linear-gradient(135deg, ${B.accent}, #7c3aed)` : B.border,
            color: valid ? "#fff" : B.textDim, fontSize: 15, fontWeight: 700, cursor: valid ? "pointer" : "not-allowed", marginTop: 8,
          }}>Enter Ballots →</button>
          <div style={{ background: B.bg, border: `1px solid ${B.border}`, borderRadius: 10, padding: "16px 20px", marginTop: 24, fontSize: 13, lineHeight: 1.6, color: B.textMuted }}>
            The script uses the <strong style={{ color: B.text }}>Weighted Inclusive Gregory Method</strong> for reallocating surplus votes. The quota for election is <strong style={{ color: B.text }}>(number of votes) / (number of seats + 1)</strong> rounded up to two decimal places. At each stage of the count, if more than one candidate has surplus votes, the largest surplus will be transferred first. All ties are broken randomly. Make sure to do +1 to the number of candidates if you have R.O.N (Re-Open Nominations).
          </div>
        </div>
      );
    }

    function BallotEntry({ numCandidates, numSeats, setNumSeats, onChangeCandidates, numVotes, candidateNames, setCandidateNames, ballots, updateBallot, onRun, onAddBallot, onRemoveBallot }) {
      const updateName = (idx, val) => { setCandidateNames((prev) => { const next = [...prev]; next[idx] = val; return next; }); };
      const hasAnyVotes = ballots.some((b) => b.some((v) => v !== null));
      const [menuOpen, setMenuOpen] = useState(false);
      const [rawSeats, setRawSeats] = useState(String(numSeats));
      const [rawCands, setRawCands] = useState(String(numCandidates));

      const handleSeatsChange = (val) => { setRawSeats(val); const p = parseInt(val, 10); if (!isNaN(p)) setNumSeats(p); };
      const handleSeatsBlur = () => { const p = parseInt(rawSeats, 10); const c = isNaN(p) ? 1 : Math.max(1, Math.min(20, p)); setNumSeats(c); setRawSeats(String(c)); };
      const handleCandsChange = (val) => { setRawCands(val); const p = parseInt(val, 10); if (!isNaN(p) && p >= 2 && p <= 26) onChangeCandidates(p); };
      const handleCandsBlur = () => { const p = parseInt(rawCands, 10); const c = isNaN(p) ? 2 : Math.max(2, Math.min(26, p)); onChangeCandidates(c); setRawCands(String(c)); };

      const canRun = hasAnyVotes && numSeats < numCandidates && numSeats >= 1;

      const settingsFields = [
        { label: "Number of Seats", value: rawSeats, onChange: handleSeatsChange, onBlur: handleSeatsBlur, min: 1, max: 20 },
        { label: "Number of Candidates", value: rawCands, onChange: handleCandsChange, onBlur: handleCandsBlur, min: 2, max: 26 },
      ];

      return (
        <div>
          <div style={{ background: B.card, borderRadius: 16, border: `1px solid ${B.border}`, padding: "24px 32px", marginBottom: 24 }}>
            <h3 style={{ margin: "0 0 16px", fontSize: 16, fontWeight: 700 }}>Candidate Names</h3>
            <div style={{ display: "flex", flexWrap: "wrap", gap: 12 }}>
              {candidateNames.map((name, i) => (
                <input key={i} value={name} onChange={(e) => updateName(i, e.target.value)}
                  style={{ padding: "8px 14px", borderRadius: 8, border: `1px solid ${B.border}`, background: B.bg, color: B.text, fontSize: 13, width: 160, outline: "none" }}
                />
              ))}
            </div>
          </div>

          <div style={{ background: B.card, borderRadius: 16, border: `1px solid ${B.border}`, padding: "24px 32px", marginBottom: 24, overflowX: "auto" }}>
            <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 6 }}>
              <h3 style={{ margin: 0, fontSize: 16, fontWeight: 700 }}>Ballot Papers</h3>
              <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                <button onClick={onAddBallot} style={{ background: B.accentSoft, border: `1px solid ${B.accent}44`, color: B.accent, padding: "6px 14px", borderRadius: 8, cursor: "pointer", fontSize: 12, fontWeight: 700 }}>+ Add Vote</button>
                <div style={{ position: "relative" }}>
                  <button onClick={() => setMenuOpen(!menuOpen)} title="Settings" style={{
                    background: menuOpen ? B.accentSoft : "transparent", border: `1px solid ${menuOpen ? B.accent + "44" : B.border}`,
                    color: menuOpen ? B.accent : B.textMuted, width: 36, height: 36, borderRadius: 8, cursor: "pointer",
                    display: "flex", alignItems: "center", justifyContent: "center", fontSize: 18, lineHeight: 1,
                  }}>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                  </button>
                  {menuOpen && (
                    <>
                      <div onClick={() => setMenuOpen(false)} style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }} />
                      <div style={{
                        position: "absolute", top: 44, right: 0, zIndex: 100,
                        background: B.card, border: `1px solid ${B.border}`, borderRadius: 12,
                        padding: "20px 24px", minWidth: 240, boxShadow: "0 12px 40px rgba(0,0,0,0.5)",
                      }}>
                        <h4 style={{ margin: "0 0 16px", fontSize: 13, fontWeight: 700, color: B.textMuted, textTransform: "uppercase", letterSpacing: "0.05em" }}>Settings</h4>
                        {settingsFields.map((f) => (
                          <div key={f.label} style={{ marginBottom: 14 }}>
                            <label style={{ display: "block", fontSize: 12, fontWeight: 600, marginBottom: 4, color: B.text }}>{f.label}</label>
                            <input type="number" min={f.min} max={f.max} value={f.value}
                              onChange={(e) => f.onChange(e.target.value)} onBlur={f.onBlur}
                              style={{ width: "100%", padding: "8px 12px", borderRadius: 8, border: `1px solid ${B.border}`, background: B.bg, color: B.text, fontSize: 14, fontWeight: 600, outline: "none", boxSizing: "border-box" }}
                            />
                          </div>
                        ))}
                        {numSeats >= numCandidates && <p style={{ color: B.red, fontSize: 12, margin: "0 0 4px" }}>Seats must be fewer than candidates.</p>}
                      </div>
                    </>
                  )}
                </div>
              </div>
            </div>
            <p style={{ margin: "0 0 20px", color: B.textMuted, fontSize: 13 }}>
              For each voter, select their ranked preferences. 1st preference is the most preferred candidate. Leave blank for no further preferences.
            </p>
            <table style={{ borderCollapse: "collapse", width: "100%", fontSize: 13 }}>
              <thead>
                <tr>
                  <th style={thStyle}>Voter</th>
                  {Array.from({ length: numCandidates }, (_, i) => <th key={i} style={thStyle}>{ordinal(i + 1)} Pref</th>)}
                  <th style={{ ...thStyle, width: 40 }}></th>
                </tr>
              </thead>
              <tbody>
                {ballots.map((ballot, vi) => (
                  <tr key={vi}>
                    <td style={{ ...tdStyle, fontWeight: 600, color: B.textMuted }}>#{vi + 1}</td>
                    {ballot.map((val, pi) => (
                      <td key={pi} style={tdStyle}>
                        <select value={val === null ? "" : val} onChange={(e) => updateBallot(vi, pi, e.target.value)}
                          style={{ width: "100%", padding: "6px 8px", borderRadius: 6, border: `1px solid ${B.border}`, background: B.bg, color: B.text, fontSize: 12, outline: "none", cursor: "pointer" }}>
                          <option value="">{"\u2014"}</option>
                          {candidateNames.map((name, ci) => <option key={ci} value={ci}>{name}</option>)}
                        </select>
                      </td>
                    ))}
                    <td style={tdStyle}>
                      {ballots.length > 1 && (
                        <button onClick={() => onRemoveBallot(vi)} title="Remove this ballot"
                          style={{ background: "transparent", border: "none", color: B.textDim, cursor: "pointer", fontSize: 16, padding: "2px 6px", borderRadius: 4, lineHeight: 1 }}>{"\u00d7"}</button>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          <button onClick={onRun} disabled={!canRun} style={{
            padding: "14px 40px", borderRadius: 10, border: "none",
            background: canRun ? `linear-gradient(135deg, ${B.green}, #059669)` : B.border,
            color: canRun ? "#fff" : B.textDim, fontSize: 15, fontWeight: 700, cursor: canRun ? "pointer" : "not-allowed",
          }}>Count Votes →</button>
        </div>
      );
    }

    function RoundCard({ round, index, candidateNames, quota }) {
      const typeColors = {
        elected: { bg: B.greenSoft, border: B.green, icon: "\u2713" },
        eliminated: { bg: B.redSoft, border: B.red, icon: "\u2717" },
        elect_remaining: { bg: B.orangeSoft, border: B.orange, icon: "\u2605" },
      };
      const tc = typeColors[round.type];

      return (
        <div style={{ marginBottom: 20, borderRadius: 12, border: `1px solid ${tc.border}33`, background: tc.bg, padding: "20px 24px" }}>
          <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 12 }}>
            <span style={{ width: 28, height: 28, borderRadius: 8, background: tc.border + "33", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 14, fontWeight: 800, color: tc.border }}>{index + 1}</span>
            <span style={{ fontSize: 14, fontWeight: 700, color: tc.border }}>{tc.icon}</span>
            <span style={{ fontSize: 14, fontWeight: 600, color: B.text, flex: 1 }}>{round.description}</span>
            {round.tiebreak && (
              <span style={{ background: "#fbbf2433", color: B.orange, border: `1px solid ${B.orange}44`, padding: "3px 10px", borderRadius: 6, fontSize: 11, fontWeight: 700, whiteSpace: "nowrap" }}>{"\ud83c\udfb2"} Random Tiebreak</span>
            )}
          </div>
          <div style={{ overflowX: "auto" }}>
            <table style={{ borderCollapse: "collapse", width: "100%", fontSize: 13 }}>
              <thead>
                <tr>
                  <th style={{ ...thSmall, textAlign: "left" }}>Candidate</th>
                  <th style={{ ...thSmall, textAlign: "right" }}>Votes</th>
                  <th style={{ ...thSmall, textAlign: "right" }}>vs Quota</th>
                  <th style={{ ...thSmall, textAlign: "center" }}>Status</th>
                </tr>
              </thead>
              <tbody>
                {Object.entries(round.tally).sort(([, a], [, b]) => b - a).map(([cIdx, votes]) => {
                  const ci = parseInt(cIdx);
                  const isElectedThisRound = round.type === "elected" && round.candidate === ci;
                  const isElectedRemaining = round.type === "elect_remaining" && round.elected && round.elected.includes(ci);
                  const isEliminatedThisRound = round.type === "eliminated" && round.candidate === ci;
                  return (
                    <tr key={ci}>
                      <td style={{ padding: "6px 8px", fontWeight: 600, color: B.text }}>{candidateNames[ci]}</td>
                      <td style={{ padding: "6px 8px", textAlign: "right", fontVariantNumeric: "tabular-nums", color: B.text }}>{roundDisplay(votes)}</td>
                      <td style={{ padding: "6px 8px", textAlign: "right", fontVariantNumeric: "tabular-nums", color: votes >= quota ? B.green : B.textMuted }}>
                        {votes >= quota ? `+${roundDisplay(votes - quota)}` : roundDisplay(votes - quota)}
                      </td>
                      <td style={{ padding: "6px 8px", textAlign: "center" }}>
                        {(isElectedThisRound || isElectedRemaining) && <span style={{ color: B.green, fontWeight: 700, fontSize: 12 }}>ELECTED</span>}
                        {isEliminatedThisRound && <span style={{ color: B.red, fontWeight: 700, fontSize: 12 }}>ELIMINATED</span>}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    function ResultsPanel({ results, candidateNames, onEditBallots }) {
      const { rounds, elected, eliminated, quota, totalVotes } = results;
      return (
        <div>
          <div style={{ background: B.card, borderRadius: 16, border: `1px solid ${B.border}`, padding: "28px 32px", marginBottom: 24 }}>
            <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 16 }}>
              <h2 style={{ margin: 0, fontSize: 20, fontWeight: 700 }}>Election Results</h2>
              <button onClick={onEditBallots} style={{ background: B.accentSoft, border: `1px solid ${B.accent}44`, color: B.accent, padding: "10px 20px", borderRadius: 8, cursor: "pointer", fontSize: 13, fontWeight: 700, display: "flex", alignItems: "center", gap: 6 }}>
                {"\u270e"} Edit Ballots & Recount
              </button>
            </div>
            <div style={{ display: "flex", gap: 24, flexWrap: "wrap", marginBottom: 20 }}>
              <Stat label="Total Votes" value={totalVotes} />
              <Stat label="Quota" value={quota} />
              <Stat label="Rounds" value={rounds.length} />
            </div>
            <h3 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 700, color: B.green }}>Elected ({elected.length})</h3>
            <div style={{ display: "flex", gap: 10, flexWrap: "wrap", marginBottom: 16 }}>
              {elected.map((c) => (
                <span key={c} style={{ background: B.greenSoft, color: B.green, border: `1px solid ${B.green}44`, padding: "6px 16px", borderRadius: 8, fontSize: 14, fontWeight: 600 }}>{candidateNames[c]}</span>
              ))}
            </div>
            {eliminated.length > 0 && (
              <>
                <h3 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 700, color: B.red }}>Eliminated ({eliminated.length})</h3>
                <div style={{ display: "flex", gap: 10, flexWrap: "wrap" }}>
                  {eliminated.map((c) => (
                    <span key={c} style={{ background: B.redSoft, color: B.red, border: `1px solid ${B.red}44`, padding: "6px 16px", borderRadius: 8, fontSize: 14, fontWeight: 600 }}>{candidateNames[c]}</span>
                  ))}
                </div>
              </>
            )}
          </div>
          <div style={{ background: B.card, borderRadius: 16, border: `1px solid ${B.border}`, padding: "28px 32px" }}>
            <h2 style={{ margin: "0 0 20px", fontSize: 18, fontWeight: 700 }}>Count Detail (Round by Round)</h2>
            {rounds.map((round, ri) => (
              <RoundCard key={ri} round={round} index={ri} candidateNames={candidateNames} quota={quota} elected={elected} />
            ))}
          </div>
        </div>
      );
    }

    // ── Main App ──────────────────────────────────────────────────────────

    function App() {
      const [step, setStep] = useState("setup");
      const [numSeats, setNumSeats] = useState(2);
      const [numCandidates, setNumCandidates] = useState(4);
      const [numVotes, setNumVotes] = useState(10);
      const [candidateNames, setCandidateNames] = useState([]);
      const [ballots, setBallots] = useState([]);
      const [results, setResults] = useState(null);

      const handleSetup = () => {
        setCandidateNames((prev) => Array.from({ length: numCandidates }, (_, i) => prev[i] || `Candidate ${i + 1}`));
        setBallots((prev) => Array.from({ length: numVotes }, (_, vi) => {
          const oldRow = prev[vi] || [];
          return Array.from({ length: numCandidates }, (_, pi) => {
            const val = oldRow[pi];
            return val !== null && val !== undefined && val < numCandidates ? val : null;
          });
        }));
        setStep("ballots");
      };

      const goBackToBallots = () => { setResults(null); setStep("ballots"); };

      const updateBallot = useCallback((voterIdx, prefIdx, value) => {
        setBallots((prev) => {
          const next = prev.map((b) => [...b]);
          next[voterIdx][prefIdx] = value === "" ? null : parseInt(value, 10);
          return next;
        });
      }, []);

      const runElection = () => {
        const parsed = ballots.map((ballot) => {
          const prefs = [];
          for (let rank = 0; rank < numCandidates; rank++) {
            const candidateIdx = ballot[rank];
            if (candidateIdx !== null && candidateIdx !== undefined) prefs.push(candidateIdx);
          }
          return prefs;
        });
        const r = runSTV(parsed, numSeats, numCandidates);
        setResults(r);
        setStep("results");
      };

      const addBallot = () => {
        setBallots((prev) => [...prev, Array.from({ length: numCandidates }, () => null)]);
        setNumVotes((v) => v + 1);
      };

      const removeBallot = (idx) => {
        setBallots((prev) => prev.filter((_, i) => i !== idx));
        setNumVotes((v) => Math.max(1, v - 1));
      };

      const changeCandidates = (newCount) => {
        const clamped = Math.max(2, Math.min(26, newCount));
        setNumCandidates(clamped);
        setCandidateNames((prev) => Array.from({ length: clamped }, (_, i) => prev[i] || `Candidate ${i + 1}`));
        setBallots((prev) => prev.map((row) => {
          return Array.from({ length: clamped }, (_, pi) => {
            const val = row[pi];
            return val !== null && val !== undefined && val < clamped ? val : null;
          });
        }));
      };

      const reset = () => { setStep("setup"); setResults(null); setBallots([]); setCandidateNames([]); };

      return (
        <div style={{ minHeight: "100vh", background: `linear-gradient(135deg, ${B.bg} 0%, #111827 100%)`, color: B.text, fontFamily: "'Segoe UI', 'Helvetica Neue', sans-serif" }}>
          <header style={{ borderBottom: `1px solid ${B.border}`, padding: "24px 32px", display: "flex", alignItems: "center", gap: 16, background: B.card }}>
            <div>
              <h1 style={{ margin: 0, fontSize: 20, fontWeight: 700, letterSpacing: "-0.02em" }}>Single Transferable Vote Counter</h1>
              <p style={{ margin: 0, fontSize: 12, color: B.textMuted }}>Weighted Inclusive Gregory Method</p>
            </div>
            {step !== "setup" && (
              <div style={{ marginLeft: "auto", display: "flex", gap: 8 }}>
                {step === "results" && (
                  <button onClick={goBackToBallots} style={{ background: B.accentSoft, border: `1px solid ${B.accent}44`, color: B.accent, padding: "8px 16px", borderRadius: 8, cursor: "pointer", fontSize: 13, fontWeight: 600 }}>
                    {"\u270e"} Edit Ballots
                  </button>
                )}
                <button onClick={reset} style={{ background: B.cardAlt, border: `1px solid ${B.border}`, color: B.textMuted, padding: "8px 16px", borderRadius: 8, cursor: "pointer", fontSize: 13, fontWeight: 500 }}>
                  {"\u2190"} Start Over
                </button>
              </div>
            )}
          </header>
          <div style={{ maxWidth: 1100, margin: "0 auto", padding: "32px 24px" }}>
            {step === "setup" && <SetupPanel numSeats={numSeats} setNumSeats={setNumSeats} numCandidates={numCandidates} setNumCandidates={setNumCandidates} numVotes={numVotes} setNumVotes={setNumVotes} onNext={handleSetup} />}
            {step === "ballots" && <BallotEntry numCandidates={numCandidates} numSeats={numSeats} setNumSeats={setNumSeats} onChangeCandidates={changeCandidates} numVotes={ballots.length} candidateNames={candidateNames} setCandidateNames={setCandidateNames} ballots={ballots} updateBallot={updateBallot} onRun={runElection} onAddBallot={addBallot} onRemoveBallot={removeBallot} />}
            {step === "results" && results && <ResultsPanel results={results} candidateNames={candidateNames} onEditBallots={goBackToBallots} />}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
